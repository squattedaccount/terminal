import json
import os
import argparse
from collections import OrderedDict

# Define the path to the i18n languages directory relative to the script's location
LANG_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'js', 'i18n', 'languages')
EN_FILE_PATH = os.path.join(LANG_DIR, 'en.json')

def load_json_file(file_path):
    """Loads a JSON file, preserving order by using OrderedDict."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f, object_pairs_hook=OrderedDict)
    except FileNotFoundError:
        return None
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from {file_path}. The file might be corrupted or empty.")
        return None

def save_json_file(data, file_path):
    """Saves data to a JSON file with UTF-8 encoding and indentation."""
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def sync_translation_keys(source_dict, target_dict):
    """
    Recursively synchronizes the keys from a source dictionary to a target dictionary.

    - It adds keys that are in `source_dict` but not in `target_dict`.
    - It recursively syncs nested dictionaries.
    - It preserves existing keys and values in `target_dict`.
    - It does NOT remove keys from `target_dict` that are not in `source_dict`.
    """
    for key, source_value in source_dict.items():
        if key not in target_dict:
            # If key is missing in target, add it with the source value (English text)
            target_dict[key] = source_value
        elif isinstance(source_value, dict) and isinstance(target_dict.get(key), dict):
            # If both are dictionaries, recurse to sync them
            sync_translation_keys(source_value, target_dict[key])
    return target_dict

LANG_METADATA = {
    'en': {'name': 'English', 'nativeName': 'English', 'isDefault': True},
    'es': {'name': 'Spanish', 'nativeName': 'Español'},
    'de': {'name': 'German', 'nativeName': 'Deutsch'},
    'zh': {'name': 'Chinese', 'nativeName': '中文'},
    'fr': {'name': 'French', 'nativeName': 'Français'},
    'fi': {'name': 'Finnish', 'nativeName': 'Suomi'},
    # Add metadata for new languages here
}

def update_language_index():
    """Dynamically generates the js/i18n/languages/index.js file."""
    print("\n--- Updating language index file --- ")
    index_file_path = os.path.join(LANG_DIR, 'index.js')
    lang_files = [f for f in os.listdir(LANG_DIR) if f.endswith('.json')]
    lang_codes = sorted([os.path.splitext(f)[0] for f in lang_files])

    # 1. Generate the availableLanguages object
    available_languages_str = "export const availableLanguages = {\n"
    for code in lang_codes:
        meta = LANG_METADATA.get(code, {'name': code, 'nativeName': code})
        available_languages_str += f"  {code}: {{\n"
        available_languages_str += f"    name: '{meta['name']}',\n"
        available_languages_str += f"    nativeName: '{meta['nativeName']}',\n"
        if meta.get('isDefault'):
            available_languages_str += f"    isDefault: true\n"
        available_languages_str += "  },\n"
    available_languages_str = available_languages_str.rstrip(',\n') + "\n};"

    # 2. Generate the switch cases for loadLanguage function
    switch_cases_str = ""
    for code in lang_codes:
        switch_cases_str += f"      case '{code}':\n"
        switch_cases_str += f"        module = await import('./{code}.json', {{ assert: {{ type: 'json' }} }});\n"
        switch_cases_str += "        break;\n"

    # 3. Create the full content of index.js using a template
    index_template = f"""/**
 * Language index
 * 
 * This file is dynamically generated by 'manage_translations.py'.
 * Do not edit this file manually, as your changes will be overwritten.
 */
import logger from '../../core/logger.js';

{available_languages_str}

// Cache for loaded language modules
const loadedLanguages = {{}};

/**
 * Lazy load a language module
 * @param {{string}} lang - Language code
 * @returns {{Promise<Object>}} - Language translations
 */
export async function loadLanguage(lang) {{
  if (loadedLanguages[lang]) {{
    return loadedLanguages[lang];
  }}

  let module;
  try {{
    switch (lang) {{
{switch_cases_str}
      default:
        // Fallback to English for any language not explicitly handled
        logger.warn(`Language '${{lang}}' not found, falling back to 'en'.`);
        module = await import('./en.json', {{ assert: {{ type: 'json' }} }});
        lang = 'en'; // Ensure we cache under the correct key
        break;
    }}
    // Handle cases where a bundler might not put the JSON behind a .default
    const translations = module.default || module;
    loadedLanguages[lang] = translations;
    return translations;
  }} catch (error) {{
    logger.error(`Failed to load language module for: ${{lang}}`, error);
    // Final fallback in case of a critical import error
    if (lang !== 'en') {{
      logger.warn(`Falling back to English due to error.`);
      return loadLanguage('en');
    }}
    return {{}};
  }}
}}

/**
 * Get the default language code
 * @returns {{string}} - Default language code
 */
export function getDefaultLanguage() {{
  for (const [code, meta] of Object.entries(availableLanguages)) {{
    if (meta.isDefault) {{
      return code;
    }}
  }}
  return 'en'; // Fallback to English if no default is specified
}}

/**
 * Check if a language is available
 * @param {{string}} lang - Language code to check
 * @returns {{boolean}} - Whether the language is available
 */
export function isLanguageAvailable(lang) {{
  return !!availableLanguages[lang];
}}
"""

    with open(index_file_path, 'w', encoding='utf-8') as f:
        f.write(index_template)
    print(f"Successfully generated '{index_file_path}' for {len(lang_codes)} languages.")

def update_nested_keys(source_dict, target_dict, key_paths):
    """Force updates specific keys in a target dictionary from a source dictionary."""
    for key_path in key_paths:
        keys = key_path.split('.')
        
        # Traverse source dictionary to get the new value
        source_val = source_dict
        try:
            for key in keys:
                source_val = source_val[key]
        except (KeyError, TypeError):
            print(f"Warning: Key path '{key_path}' not found in source 'en.json'. Skipping.")
            continue

        # Traverse target dictionary to update the value
        target_level = target_dict
        try:
            for i, key in enumerate(keys[:-1]):
                target_level = target_level[key]
            
            last_key = keys[-1]
            if last_key in target_level:
                print(f"  - Updating key '{key_path}'")
                target_level[last_key] = source_val
            else:
                print(f"Warning: Key path '{key_path}' does not exist in target file. It will be added by the sync process.")

        except (KeyError, TypeError):
            print(f"Warning: Could not traverse key path '{key_path}' in target file. It may be added by the sync process.")

    return target_dict

def main():
    """Main function to run the synchronization script."""
    parser = argparse.ArgumentParser(
        description='Create or synchronize i18n language files with en.json as the source.',
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument(
        'lang_codes',
        nargs='+',
        help='One or more language codes to process (e.g., zh de fr).'
    )
    parser.add_argument(
        '--force-overwrite',
        action='store_true',
        help='Force overwrite of existing files with the content of en.json. USE WITH CAUTION.'
    )
    parser.add_argument(
        '--update-keys',
        nargs='+',
        metavar='KEY_PATH',
        help='One or more dot-separated key paths to forcibly update from en.json (e.g., commands.collection.text).'
    )

    args = parser.parse_args()

    if not os.path.exists(EN_FILE_PATH):
        print(f"Error: English source file 'en.json' not found in {LANG_DIR}")
        return

    print(f"Loading English source file: {EN_FILE_PATH}")
    en_data = load_json_file(EN_FILE_PATH)
    if en_data is None:
        return

    for lang_code in args.lang_codes:
        if lang_code.lower() == 'en':
            print("Skipping 'en' as it is the source language.")
            continue

        target_file_path = os.path.join(LANG_DIR, f"{lang_code}.json")
        print(f'\n--- Processing language: {lang_code} ---')

        target_data = load_json_file(target_file_path)

        if target_data is None or args.force_overwrite:
            if args.force_overwrite:
                print(f"Forcefully overwriting '{target_file_path}' with content from 'en.json'.")
            else:
                print(f"'{target_file_path}' not found or is invalid. Creating a new file.")
            synced_data = en_data
        else:
            # First, force update specified keys if any
            if args.update_keys:
                print(f"Force updating specified keys in '{target_file_path}'...")
                target_data = update_nested_keys(en_data, target_data, args.update_keys)
            
            # Then, synchronize any missing keys
            print(f"Synchronizing missing keys in '{target_file_path}'...")
            synced_data = sync_translation_keys(en_data, target_data)

        save_json_file(synced_data, target_file_path)
        print(f"Successfully created/updated '{target_file_path}'.")

    print("\nSynchronization complete. Please review the files to add new translations.")

    # After syncing, update the language index file
    update_language_index()

if __name__ == '__main__':
    main()
